### C++学习
学习的过程中可以始终思考一个问题：C++的这些语法是怎么实现的，特别是用C语言怎么实现的，因为C++代码都可以转换成C代码
1.  构造与析构
    * 对象初始化，初始化列表
    * 初始化和赋值是不一样的
    * 初始化列表：成员变量初始化，父类构造函数（想一想初始化列表的顺序问题）
    * 拷贝构造，函数返回值或者参数为对象，好难，没搞懂
    * class里面的都是声明不是定义
2. 对象组合（软件重用的方式之一）
    * 拿已有对象拼装出新的对象
3. 继承（软件重用的方式之一）
   * 拿已有的类改造得到新的类，superset与super class
   * 子类与父类
   * 访问属性
  name hiding子类出现和父类相同的函数（C++特殊的OOP，重载的处理方式）
4. 重载
      * 函数参数不同，仅仅返回值不同不是重载编译器会报错
      * 缺省参数（从右向左，函数原型中.h文件给出）
 5. 内联函数（inline）（比宏多了类型检查，更加安全）
     * 在.h中写inline函数的body，inline函数不要.cpp文件
     * 递归、很大的函数无法inline
     * 类的成员函数直接给出定义，实际上就是inline
   6. 引用（比指针写代码更优雅，少了很多*与&符号）
	   * 成员变量是引用，需要在构造函数的初始化列表中
	   * 函数返回值为引用类型（可作为左值）的时候需要注意生命周期的问题，例如不可返回函数内部本地变量的引用，传参传引用（加上const更安全）
	   * const是编译时检查的，3*i不是左值，不可以作为void f(int & i)的参数，可以作为void f(const int & i)的参数，可以想象编译器把3*i分配了const类型的临时变量
	   * 函数返回值可以是函数本地对象变量，有什么意义（C++的内存模型）
  6. 多态
	  * 虚函数（任何一个类如果有虚函数，就会比正常情况下大一点，大的是什么？多态的实现？virtual是的父类和子类的同名函数联系起来，析构函数为什么有时需要声明为虚函数？）
	  * 向上造型
	  * 动态绑定
	  * 查下资料：C++对象之间可以直接赋值，但是到底是什么意思
	7. static关键字：全局（hidden：访问属性已经实现该功能了,persistant：不依赖于某个对象而存在，类级别的）
		* 静态成员
		* **没有对象之前也可以访问类的静态成员函数和静态成员变量**，静态成员函数可以访问非静态的成员变量或者成员函数吗？不行，静态成员函数中也不可以使用this，在还没有对象时可以这样访问，类名::静态成员函数
	8. 运算符重载（允许运算符对用户定义的类/枚举类型做运算时可以不使用默认的运算功能，而使用用户写的运算功能）
		* 可以重载的运算符
		* 重载的限制：已有运算符，运算符的操作数保持不变，优先级不变
		* 可以是成员函数（由于隐藏的this在写的时候可以少写一个参数），也可以是全局的函数
		* receiver的概念
		* 成员or非成员
		* 运算符重载原型：参数传递，返回类型（能不能做左值要不要const，是不是引用？），++前缀和后缀区别，[]index运算符返回类型引用
		* 运算符赋值，涉及到动态分配内存的，需要注意
		* 运算符重载-类型转换，explicit
5. 函数模板
   *  template（声明而非定义，编译器干了很多事情）
	   * 重用代码，将类型作为class或者函数的参数（函数模板，模板函数，类模板，模板类）
	   * 参数列表中没有出现类型T的时候，在使用的时候需要注意，见下面的例子
		   ```
		   template <class T>
		   void f(void)   {/* ... */}
		   f<int>();//type is int
		   f<float>();//type T is float
		   ```
		* 类模板中的每一个函数都是函数模板，类名后面要加上<T>
 6. assert
	 * 使用时需要包含头文件`#include <assert.h>`
	 * assert(expr) //assert是宏，当expr条件返回错误，则终止执行，一般还会给出错误信息
6. exception
	* 异常处理，throw，底层抛出，随着调用链传播，上层处理，try catch
	* 函数后面加上`void abc(int a):throw(MathErr){}`表示函数里面只能抛出的异常类型
7. 流
	* 流的概念，文本文件和二进制文件
* tips：
